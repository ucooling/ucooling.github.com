
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>马立斌技术博客</title>
  <meta name="author" content="Malrin">

  
  <meta name="description" content="背景介绍 参加工作的两年时间里，刚开始工作的时候是一家日企，使用的版本管理工具是SVN，对于一个初涉职场的新手来说学习这个不是很困难，并且有很多的工具可以使用，但是这种工具有很多的局限性，而且很不方便，对于公司层面来讲确实是一个很好的选择， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ucooling.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="马立斌技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">马立斌技术博客</a></h1>
  
    <h2>学会蹲下才能跳的更高.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="ucooling.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/about">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/10/git-introduction/">Git Introduction</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-10T11:51:44+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:51 am</span></time>
        
           | <a href="/blog/2015/05/10/git-introduction/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/05/10/git-introduction/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>背景介绍</h2>

<p>参加工作的两年时间里，刚开始工作的时候是一家日企，使用的版本管理工具是SVN，对于一个初涉职场的新手来说学习这个不是很困难，并且有很多的工具可以使用，但是这种工具有很多的局限性，而且很不方便，对于公司层面来讲确实是一个很好的选择，但是对于个人来讲使用SVN来管理自己的代码确实不是一个很好的选择，而且很不方面。从我准备开始换工作的时候我开始注意到了Git，开始的时候对它有一种敬畏的心态，总觉的这个东西很难学会，事实上确实很难学会，他的学习曲线是比较长，但是当你真正的掌握他的精髓的时候你就会开始觉得这会是一个很好的工具，下面的内容我会介绍一些我自己对于Git的一些使用的理解。</p>

<h2>什么是版本控制</h2>

<p>下面这段是从Git的官网教程中摘抄来的，“版本控制是一种记录一个或者若干文件内容变化，以便将来查阅特定版本修改情况的系统”。采用版本控制是一个明智的选择，有了它你可以将某个文件回溯到之前的状态，甚至将整个项目回退到之前某个时间点的状态。你可以比较文件的细节变化，查出最后是谁修改了那个地方，从而找出问题的原因，有是谁在什么时间提交修改了什么文件。使用版本控制系统还意味着，就算你把整个项目中的文件搞的乱七八糟，你也照样可以轻松恢复到原来的样子，但是额外增加的工作量却微乎其微。</p>

<h2>集中式和分布式的比较</h2>

<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候用的都是自己的电脑，所以每次干活之前都需要从中央服务器取得最新的版本，然后开始自己的工作，干完活之后，再把自己的东西提交到中央服务器。
集中式最大的痛点就是必须联网才能工作，如果中央服务器在局域网还好，但是如果在互联网，如果网速慢那就悲剧了，如果你是一个急性子的人，你会被气的得精神病的。
和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人的电脑里都有一个完整的版本库，某一个人得电脑坏了不要紧，随时从其他人呢那里复制一个就可以了，而集中式版本控制系统的中央服务器出了问题，所有的人就都没有办法干活了。</p>

<h2>Git基础</h2>

<ul>
<li>直接记录快照，而非进行差异比较</li>
</ul>


<p><img src="images/git.png" alt="Git版本控制" /></p>

<ul>
<li>几乎所有的操作都在本地进行</li>
</ul>


<p>Git不用跑到外边的服务器上拿数据，而直接是从本地的数据库中获取数据，所以在任何的时候你都可以马上的翻阅自己的历史记录，无需等待，如果想要看当前版本的文件和一个月前的版本的差异，Git会取出当前一个月的快照，不用到远程的服务器来查看快照。</p>

<ul>
<li><p>时刻保持数据的完整性
在保存Git之前，所有的数据都要进行内容的检验和计算，并将此结果作为数据标识和缩引，Git使用SHA-1算法计算数据的校验和，通过对文件的内容和目录的结构做出一个SHA-1哈希值，作为指纹字符串，Git的工作完全依赖于这类指纹字符串。</p></li>
<li><p>文件的三种状态</p></li>
</ul>


<p>对于Git管理的任何一个文件，在Git的内部都只有三种状态：已经提交（committed）,已经修改（modified）和已经暂存（staged），已经提交表示已经提交到本地的数据库中，已经修改表示修改了某个文件但是还没有提交保存，已经暂存表示已经被被修改的文件保存到了下次提交的保存清单中git
<img src="images/git_status.png" alt="Git文件状态" /></p>

<p>Git的基本工作流程是，
1 从master分支上新建一个分支，记住永远不要再master分支上直接工作，这样做有很多的弊端
2 切换到新建的分支，在该分支上对某些文件进行修改
3 对修改后的文件进行快照，然后保存到暂存区域
4 提交更新，将保存在暂存区域的文件快照永久存储到Git目录中。</p>

<h2>Mac上安装Git</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install git</span></code></pre></td></tr></table></div></figure>


<h2>第一次使用Git时的简单配置</h2>

<p>Git提供了一个叫做git config的工具，改工具专门用来配置或者读取响应的工作环境变量，这些变量会被存储在三个地方
* /etc/gitconfig 对系统中的所有用户都普遍适用的配置
* ~/.gitconfig 用户目录下的配置文件只适用于改用户
* 当前项目的Git配置文件（.git/config）</p>

<p>常用命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global user.name "Username"
</span><span class='line'>git config --global user.email Username@example.com
</span><span class='line'>git config --global merge.tool vimdiff
</span><span class='line'>git config --list</span></code></pre></td></tr></table></div></figure>


<h2>Git项目初始化</h2>

<ul>
<li>在本地初始化一个Git项目</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git init .</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从远程克隆一个现有项目</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/username/project.git
</span><span class='line'>git clone git://github.com/username/project.git</span></code></pre></td></tr></table></div></figure>


<h2>Git常使用命令解析</h2>

<ul>
<li>查看文件状态</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git status</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看尚未暂存的文件更新了那部分</li>
</ul>


<p>此命令查看的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git diff</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看已经暂存起来的文件和上次提交时的快照之间的差异</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git diff --cached
</span><span class='line'>#more than 1.6.1 version
</span><span class='line'>git diff --staged</span></code></pre></td></tr></table></div></figure>


<ul>
<li>提交更新</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -m "comments"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>跳过使用暂存区域</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a -m "comments"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>移动文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git mv file_from file_to</span></code></pre></td></tr></table></div></figure>


<p>运行上边的命令相当于执行了下边的三条命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mv test test.rb
</span><span class='line'>git rm test
</span><span class='line'>gir add test.rb</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看提交历史</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git log
</span><span class='line'>#查看最近两次提交的内容差异
</span><span class='line'>git log -p -2
</span><span class='line'>#每次提交增改行数的统计
</span><span class='line'>git log --stat
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改最后一次提交</li>
</ul>


<p>有时候我们提交完了之后发现漏掉了一些文件没有提交，或者是提交信息写错了，想要撤销刚才的提交操作，可以使用 &ndash;amend选项重新提交</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit --amend</span></code></pre></td></tr></table></div></figure>


<ul>
<li>取消已经暂存的文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset .
</span><span class='line'>git reset HEAD file_name</span></code></pre></td></tr></table></div></figure>


<ul>
<li>取消对文件的修改</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout file_name</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看当前远程库信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote -v</span></code></pre></td></tr></table></div></figure>


<ul>
<li>添加远程仓库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote add [shortname] [url]
</span><span class='line'>git remote add upstream git://github.com/paulboone/ticgit.git</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从远程仓库抓取数据</li>
</ul>


<p>要抓取本次仓库没有的信息可以运行下面的命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git fetch [remote-name]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>推送数据到远程仓库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git push origin master</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改、删除远程分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote rename upstream origin
</span><span class='line'>git remote rm upstream</span></code></pre></td></tr></table></div></figure>


<ul>
<li>标签相关</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git tag  //显示所有的标签
</span><span class='line'>git tag -l 'v1.4.2.*'  //只显示1.4.2系列的标签
</span><span class='line'>git tag -a v1.1 -m 'my first version 1.1'  //添加标签</span></code></pre></td></tr></table></div></figure>


<ul>
<li>添加并切换分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git branch -b [branch-name]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>切换分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout [branch-name]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>合并分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout -b test-branch //新建了一个分支
</span><span class='line'>git merge master //将master分支合并到该分支</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git branch -d [branch-name]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>遇到冲突是的分支合并</li>
</ul>


<p>可以看到 ======= 隔开的上半部分，是 HEAD中的内容，下半部分是分支中的内容，二者自选其一手动整合</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git mergetool //使用图形界面来解决冲突</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看个分支最后一次提交的信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git branch -v</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看已经合并/没有合并的分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git branch --merged
</span><span class='line'>git branch --no-merged</span></code></pre></td></tr></table></div></figure>


<ul>
<li>分支的衍合</li>
</ul>


<p>把一个分支中的修改整合到另一个分支的办法有两种：merge和rebase
对于merge理解非常的简单，就是合并两个分支，合并两个分支的另一种方法就是衍合，简单地来讲，就是把另一个分支产生的变化补丁在需要衍合的分支中重新打一遍，这种操作就叫做衍合</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout [branch-name]
</span><span class='line'>git rebase master  //衍合master分支的内容到现在的分支</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成SSH公钥</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen</span></code></pre></td></tr></table></div></figure>


<ul>
<li>储藏你的工作</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git stash
</span><span class='line'>git stash pop
</span><span class='line'>git stash list
</span><span class='line'>git stash apply stash@{2}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/22/jasmine/">Jasmine</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-22T21:53:43+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>9:53 pm</span></time>
        
           | <a href="/blog/2015/04/22/jasmine/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/22/jasmine/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>简介</h2>

<p>页面前端逻辑复杂度与日俱增，前端工程师写出来的javascript变得庞大甚至臃肿，维护的难度不断加大，你需要一个javascript单元测试框架，用于降低维护javascript代码时的出错风险，保证重构后的代码的兼容性，最重要的是减少人肉测试的过程，降低js代码维护成本。jasmine无疑是目前最优秀的javascript单元测试框架之一，目前淘宝UED正在使用，在易用性和质量上都非常不错。</p>

<h2>BDD</h2>

<p>BDD是一种敏捷软件开发技术，它鼓励软件项目开发中的开发者、测试人员和非技术参与者之间的协作，BDD最初是由Dan North在2003年命名的，它包括验收和客户驱动等得极限编程时间，作为一种软件开发的实践方式，在这几年当中得到了极大的发展。
BDD的重点是通过与利益相关者的讨论取得对预期的软件行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。行为驱动开发人员使用混合了领域中统一的语言的母语语言来描述他们的代码的目的。这让开发者得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度的减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价。</p>

<h2>常见API</h2>

<ul>
<li>describe</li>
</ul>


<p>一个测试开始于全局函数describe, 一个describe是一个it的集合，当然它也可以包含describe.</p>

<p>语法格式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe(string, function)</span></code></pre></td></tr></table></div></figure>


<p>string: 测试组名称(测试描述)
function: 测试组函数</p>

<ul>
<li>it</li>
</ul>


<p>它是对一个具体测试的描述</p>

<p>语法格式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>it(string function)</span></code></pre></td></tr></table></div></figure>


<p>string: 测试逻辑函数（具体干活的主)
function: 测试函数</p>

<ul>
<li>spyOn</li>
</ul>


<p>存储函数被调用情况和参数（函数监视器，记录被调用情况，但是被监视的函数并不会真正的执行）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe('spy sync', function() {
</span><span class='line'>  var foo, bar = null;
</span><span class='line'>  
</span><span class='line'>  beforeEach(function() {
</span><span class='line'>    foo={
</span><span class='line'>     setValue: function(value) {
</span><span class='line'>       bar = value;
</span><span class='line'>     }
</span><span class='line'>    };
</span><span class='line'>    spyOn(foo, 'setValue');
</span><span class='line'>    foo.setValue(123);
</span><span class='line'>  });
</span><span class='line'>  it("tracks all the spy was called", function() {
</span><span class='line'>    expect(foo.setValue).toHaveBeenCalledWithed();
</span><span class='line'>  });
</span><span class='line'>  it("tracks all the arguments of its calls", function() {
</span><span class='line'>    expect(foo.setBar).toHaveBeenCalledWith(123);
</span><span class='line'>  });
</span><span class='line'>  it("stops all execution on a function", function() {
</span><span class='line'>    expect(bar).toBeNull();
</span><span class='line'>  });  
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>createSpy</li>
</ul>


<p>有这样一种需求，就是说你想监视一个对象，但是又没有办法获得这个对象，这个时候该怎么办呢，createSpy就为我们提供了这样的功能，可以自己create一个被监视的函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("CloseButton", function () {
</span><span class='line'>  "use strict";
</span><span class='line'>
</span><span class='line'>  var component;
</span><span class='line'>  beforeEach(function () {
</span><span class='line'>    var CloseIcon = require('components/close_button.jsx');
</span><span class='line'>    component = fixture.renderComponent(CloseButton, {
</span><span class='line'>      closeWindow: jasmine.createSpy('closeWindow')
</span><span class='line'>    });
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>  describe("clicking on close button", function () {
</span><span class='line'>    it("closes the window", function () {
</span><span class='line'>      $j(component.getDOMNode()).simulateClick();
</span><span class='line'>      expect(component.props.closeWindow).toHaveBeenCalled();
</span><span class='line'>    });
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>createSpyObj</li>
</ul>


<p>有时监视一个对象的很多方法，这个时候用createSpyObi添加方法数组，来完成
比如说现在有这样的一个需求：想要监视一个输入框的获得鼠标焦点和失去鼠标焦点这个一个需求。我们可以按照以下的方法来写这个测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("test input stuff", function() {
</span><span class='line'>  var input;
</span><span class='line'>  
</span><span class='line'>  beforeeEach(function() {
</span><span class='line'>    input = jasmine.createSpyObj('input', ['GainFocus', 'LostFocus']);
</span><span class='line'>    input.GainFocus();
</span><span class='line'>    input.LostFocus();
</span><span class='line'>  });
</span><span class='line'>  it('input methods have been defined', function() {
</span><span class='line'>    expect(input.GainFocus).toBeDefined();
</span><span class='line'>    expect(input.LostFocus).toBeDefined();
</span><span class='line'>  });
</span><span class='line'>  it('input methods have been called', function() {
</span><span class='line'>    expect(input.GainFocus).toHaveBeenCalled();
</span><span class='line'>    expect(input.LostFocus).toHaveBeenCalled();
</span><span class='line'>  })
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>and.returnValue</li>
</ul>


<p>给被监视的函数定义一个返回值。
比如说现在有这样一个场景，前端通过js给某个组件添加一个toggle, 如果isOn函数返回是true就显示component，否则不显示。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe('Component body', function() {
</span><span class='line'>  var component;
</span><span class='line'>  
</span><span class='line'>  beforeEach(function() {
</span><span class='line'>    component = {
</span><span class='line'>      isOn: function() {
</span><span class='line'>        return false;
</span><span class='line'>      };
</span><span class='line'>    };
</span><span class='line'>  });
</span><span class='line'>  spyOn(component, "isOn").and.returnValue(true);
</span><span class='line'>  
</span><span class='line'>  it("isOn return true", function() {
</span><span class='line'>    expect(component.getDOMNode().getAttribute('class')).toContain('xxx');
</span><span class='line'>  })
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<ul>
<li>and.callFake</li>
</ul>


<p>add.callFake替代被监视的函数，原函数并不执行。
比如说现在的Ajax的测试，我们在测试它的时候并不需要真正的去请求一个Ajax，这个时候我们就可以使用改测试方法。
下面是一个项目中的测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe('callFake example', function() {
</span><span class='line'>  var stubPriceResults = [{"priceResult": 10000}];
</span><span class='line'>  
</span><span class='line'>  beforeEach(function () {
</span><span class='line'>    spyOn($, 'ajax').and.callFake(function (o) {
</span><span class='line'>      o.success(stubPriceResults);
</span><span class='line'>    });
</span><span class='line'>    PriceCallback = jasmine.createSpy("my-function");
</span><span class='line'>  });
</span><span class='line'>  
</span><span class='line'>  it("triggers ajax request with correct url", () =&gt; {
</span><span class='line'>      Project.ExecAjax.Price("VIC", "6010", "someplace", "house", 2, PriceCallback);
</span><span class='line'>      expect($.ajax).toHaveBeenCalledWith({
</span><span class='line'>        type: 'get',
</span><span class='line'>        dataType: 'json',
</span><span class='line'>        url: 'http:xxx.xx.xxx.json',
</span><span class='line'>        success: jasmine.any(Function),
</span><span class='line'>        error: jasmine.any(Function)
</span><span class='line'>      });
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<ul>
<li>and.callThrough</li>
</ul>


<p>add.CallThrough同样也是一个函数监视器，但函数真的执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("对spy函数的测试，函数真的执行", function() {
</span><span class='line'>    var foo, bar, fetchedBar;
</span><span class='line'> 
</span><span class='line'>    beforeEach(function() {
</span><span class='line'>        foo = {
</span><span class='line'>            setBar: function(value) {
</span><span class='line'>                bar = value;
</span><span class='line'>            },
</span><span class='line'>            getBar: function() {
</span><span class='line'>                return bar;
</span><span class='line'>            }
</span><span class='line'>        };
</span><span class='line'> 
</span><span class='line'>        //spyOn(foo, "setBar");    //如果加上这句，setBar不真的执行，后两个spec不通过
</span><span class='line'>        spyOn(foo, 'getBar').andCallThrough();
</span><span class='line'> 
</span><span class='line'>        foo.setBar(123);
</span><span class='line'>        fetchedBar = foo.getBar();
</span><span class='line'>    });
</span><span class='line'> 
</span><span class='line'>    it("测试foo中getBar函数是否被调用过", function() {
</span><span class='line'>        expect(foo.getBar).toHaveBeenCalled();
</span><span class='line'>    });
</span><span class='line'> 
</span><span class='line'>    it("foo中setBar函数真的执行了", function() {
</span><span class='line'>        expect(bar).toEqual(123);
</span><span class='line'>    });
</span><span class='line'> 
</span><span class='line'>    it("foo中getBar函数真的执行了", function() {
</span><span class='line'>        expect(fetchedBar).toEqual(123);
</span><span class='line'>    });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>and.throwError</li>
</ul>


<p>定义当调用一个函数的时候，返回一个异常</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("throwError, when configured to throw an error", function() {
</span><span class='line'>  var foo, bar;
</span><span class='line'>  
</span><span class='line'>  deforeEach(function(){
</span><span class='line'>    foo = {
</span><span class='line'>      setBar: function(value) {
</span><span class='line'>        bar = value;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>    spyOn(foo, "setBar").and.throwError("exception");
</span><span class='line'>  });
</span><span class='line'>  it("throws the value", function() {
</span><span class='line'>    except(function(){
</span><span class='line'>      foo.setBar(123)
</span><span class='line'>    }).toThrowError("exception");
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>and.stub</li>
</ul>


<p>我是这样来理解stub函数的，我们可能需要同时需要测试一个函数被执行和不被执行时某个参数的值.这个时候可以先测试被执行是某个参数的值，然后将函数stub起来，再将需要测试的参数设置为原来的值，然后再执行该函数，来测试需要测试的参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("A spy", function() {
</span><span class='line'>  var foo, bar = null;
</span><span class='line'>
</span><span class='line'>  beforeEach(function() {
</span><span class='line'>    foo = {
</span><span class='line'>      setBar: function(value) {
</span><span class='line'>        bar = value;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    spyOn(foo, 'setBar').and.callThrough();
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>  it("can call through and then stub in the same spec", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    expect(bar).toEqual(123);
</span><span class='line'>
</span><span class='line'>    foo.setBar.and.stub();
</span><span class='line'>    bar = null;
</span><span class='line'>
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    expect(bar).toBe(null);
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>calls</li>
</ul>


<p>calls.any():测试函数是否被调用过。</p>

<p>calls.count():测试函数被调用的次数。</p>

<p>calls.argsFor(n):测试函数第n次调用时候所使用的参数。</p>

<p>calls.allArgs():测试函数所有被调用过得参数</p>

<p>calls.all():测试调用函数的对象，被调用时的参数，调用函数后的返回值。</p>

<p>calls.mostRecent():函数最近一次被调用的情况，包括调用函数的对象，调用函数时的参数，以及调用函数后的返回值。</p>

<p>calls.first():类似于上边，只是他反应的是第一次调用的情况。
下边的例子来自于官网：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("A spy", function() {
</span><span class='line'>  var foo, bar = null;
</span><span class='line'>
</span><span class='line'>  beforeEach(function() {
</span><span class='line'>    foo = {
</span><span class='line'>      setBar: function(value) {
</span><span class='line'>        bar = value;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    spyOn(foo, 'setBar');
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.any(): returns false if the spy has not been called at all, and then true once at least one call happens.
</span><span class='line'>
</span><span class='line'>  it("tracks if it was called at all", function() {
</span><span class='line'>    expect(foo.setBar.calls.any()).toEqual(false);
</span><span class='line'>
</span><span class='line'>    foo.setBar();
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.any()).toEqual(true);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.count(): returns the number of times the spy was called
</span><span class='line'>
</span><span class='line'>  it("tracks the number of times it was called", function() {
</span><span class='line'>    expect(foo.setBar.calls.count()).toEqual(0);
</span><span class='line'>
</span><span class='line'>    foo.setBar();
</span><span class='line'>    foo.setBar();
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.count()).toEqual(2);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.argsFor(index): returns the arguments passed to call number index
</span><span class='line'>
</span><span class='line'>  it("tracks the arguments of each call", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    foo.setBar(456, "baz");
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.argsFor(0)).toEqual([123]);
</span><span class='line'>    expect(foo.setBar.calls.argsFor(1)).toEqual([456, "baz"]);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.allArgs(): returns the arguments to all calls
</span><span class='line'>
</span><span class='line'>  it("tracks the arguments of all calls", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    foo.setBar(456, "baz");
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.allArgs()).toEqual([[123],[456, "baz"]]);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.all(): returns the context (the this) and arguments passed all calls
</span><span class='line'>
</span><span class='line'>  it("can provide the context and arguments to all calls", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.all()).toEqual([{object: foo, args: [123], returnValue: undefined}]);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.mostRecent(): returns the context (the this) and arguments for the most recent call
</span><span class='line'>
</span><span class='line'>  it("has a shortcut to the most recent call", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    foo.setBar(456, "baz");
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.mostRecent()).toEqual({object: foo, args: [456, "baz"], returnValue: undefined});
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.first(): returns the context (the this) and arguments for the first call
</span><span class='line'>
</span><span class='line'>  it("has a shortcut to the first call", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    foo.setBar(456, "baz");
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.first()).toEqual({object: foo, args: [123], returnValue: undefined});
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>When inspecting the return from all(), mostRecent() and first(), the object property is set to the value of this when the spy was called.
</span><span class='line'>
</span><span class='line'>  it("tracks the context", function() {
</span><span class='line'>    var spy = jasmine.createSpy('spy');
</span><span class='line'>    var baz = {
</span><span class='line'>      fn: spy
</span><span class='line'>    };
</span><span class='line'>    var quux = {
</span><span class='line'>      fn: spy
</span><span class='line'>    };
</span><span class='line'>    baz.fn(123);
</span><span class='line'>    quux.fn(456);
</span><span class='line'>
</span><span class='line'>    expect(spy.calls.first().object).toBe(baz);
</span><span class='line'>    expect(spy.calls.mostRecent().object).toBe(quux);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>.calls.reset(): clears all tracking for a spy
</span><span class='line'>
</span><span class='line'>  it("can be reset", function() {
</span><span class='line'>    foo.setBar(123);
</span><span class='line'>    foo.setBar(456, "baz");
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.any()).toBe(true);
</span><span class='line'>
</span><span class='line'>    foo.setBar.calls.reset();
</span><span class='line'>
</span><span class='line'>    expect(foo.setBar.calls.any()).toBe(false);
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<ul>
<li>toHaveBeenCalled</li>
</ul>


<p>测试函数是否被调用</p>

<ul>
<li>toHaveBeenCalledWith</li>
</ul>


<p>测试函数被固定的参数调用</p>

<ul>
<li>matcher</li>
</ul>


<p>toBeDefined: 是否被定义；</p>

<p>toBeUndefined: 是否没有被定义；</p>

<p>toBeNull: 值是否为Null;</p>

<p>toBeTruthy: 是否被赋值；</p>

<p>toBeFalsy: 是否没有被赋值；</p>

<p>toContain: 是否包含某个字符串；</p>

<p>toBeLessThan: 是否小于某个值；</p>

<p>toBeGreaterThan:是否打印某个值；</p>

<p>toBeCloseTo:</p>

<p>toThrow: 测试一个函数执行是否会异常；</p>

<p>toThrowError:</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/21/active-job/">Active-job</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-21T23:11:02+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>11:11 pm</span></time>
        
           | <a href="/blog/2015/04/21/active-job/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/21/active-job/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>初探ActiveJob</h2>

<p>ActiveJob 是 Rails 4.2 新加入的功能。这个东西在beta阶段rubyChina就已经有很多高手关注了</p>

<h3>简介</h3>

<p>ActiveJob 是Rails自己开发运行后台程序的模块，常用于执行运行时间可能很长的工作（比如发送注册邮件）。</p>

<p>当然这种需求实际上非常普遍，所以rails 也有相应的第三方gem来解决这个需求，比如著名的Sidekiq和Resque等。<strong>ActiveJob的出现不是为了代替他们</strong>，而是统一了原来Resque、Sidekiq 等其他gem对后台运行程序的各种千奇百怪的写法。</p>

<p>本文使用的后台程序gem包是‘delayed_job_active_record’</p>

<ul>
<li>使用以下的命令创建deplayed_job table</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rails g delayed_job:active_record
</span><span class='line'>rake db:migrate</span></code></pre></td></tr></table></div></figure>


<ul>
<li>要想使用ActiveJob官方文档给出了示例
首先在命令行中执行如下的命令(add_lots_of_users是需要创建的job的名字)：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rails g job add_lots_of_users</span></code></pre></td></tr></table></div></figure>


<p>打开app/jobs里边会多出一个ruby文件，该文件就是我们的active job 文件
文件内容类似下边</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AddLotsOfUsersJob &lt; ActiveJob::Base
</span><span class='line'>  queue_as :default
</span><span class='line'>
</span><span class='line'>  def perform(*args)
</span><span class='line'>    # Do something later
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>我们可以将需要跑的后台程序写到perform文件中，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def perform(*args)
</span><span class='line'>    # Do something later
</span><span class='line'>    sleep 10
</span><span class='line'>    1000.times do |index|
</span><span class='line'>      user = User.new
</span><span class='line'>      user.name = "atpking#{index}"
</span><span class='line'>      user.save
</span><span class='line'>    end
</span><span class='line'>  end  </span></code></pre></td></tr></table></div></figure>


<p> 改后台程序可以在任何的地方调用，下面是一个简单的调用，在加载用户首页的时候去执行改后台程序</p>

<pre><code class="`"> class UsersController &lt; ApplicationController
  before_action :set_user, only: [:show, :edit, :update, :destroy]

  # GET /users
  # GET /users.json
  def index
    AddLotsOfUsersJob.perform_later
    @users = User.all
  end
end
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/08/ruby-aws-sqs-received-message/">Ruby-aws-sqs(received Message)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-08T00:05:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:05 am</span></time>
        
           | <a href="/blog/2015/04/08/ruby-aws-sqs-received-message/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/08/ruby-aws-sqs-received-message/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>读取消息其实也是非常的简单，以下将从两个方面来介绍如何从AWS的SQS获取消息。</p>

<h2>Received message</h2>

<p>从SQS读取消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'aws-sdk'
</span><span class='line'>require 'json'
</span><span class='line'>
</span><span class='line'>credential = Aws::Credentials.new('access_key_id', 'secret_access_key')
</span><span class='line'>Aws.config.update(credentials: credential, region: 'region')
</span><span class='line'>
</span><span class='line'>queue = Aws::SQS::Client.new()
</span><span class='line'>
</span><span class='line'>message = queue.receive_message('queue_url')</span></code></pre></td></tr></table></div></figure>


<h2>poller message</h2>

<p>订阅SQS的消息，当SQS获取消息，订阅者就可以或得更新的消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'aws-sdk'
</span><span class='line'>require 'json'
</span><span class='line'>
</span><span class='line'>credential = Aws::Credentials.new('access_key_id', 'secret_access_key')
</span><span class='line'>Aws.config.update(credentials: credential, region: 'region')
</span><span class='line'>
</span><span class='line'>queue = Aws::SQS::QueuePoller.new('queue_url')
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>puts "enter the queue"
</span><span class='line'>queue.poll do |msg|
</span><span class='line'>  puts msg.body
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<h2>参考文档</h2>

<p><a href="http://docs.aws.amazon.com/sdkforruby/api/Aws/SQS/Client.html">aws-sdk docs</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/06/rspec-yu-fa-jie-shao/">Rspec 语法介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-06T23:08:16+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:08 pm</span></time>
        
           | <a href="/blog/2015/04/06/rspec-yu-fa-jie-shao/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/06/rspec-yu-fa-jie-shao/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>关键字</h2>

<ul>
<li>describe 和 context</li>
</ul>


<p>以上两个关键字是帮助你组织分类的，都是可以任意套叠的.
使用一个字符串作为他们的参数，以及使用一个block来定义其上下文的范围。
写model的spec或者其他的unit test时，可以传一个Ruby的类作为describe的第一个参数，例如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#测试类
</span><span class='line'>describe Users do
</span><span class='line'>  #测试方法
</span><span class='line'>  context '#test' do
</span><span class='line'>      it 'should ...' do
</span><span class='line'>          ......
</span><span class='line'>      end
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>let</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let(:name) { expression }</span></code></pre></td></tr></table></div></figure>


<p>let方法简单地使用后面的block创建memoized attributes.换句话说就是为后边的测试准备数据，定义的属性可以在多个例子中使用，但是不能跨多个实例调用。跟before里地代码类似，但是比before里测代码效果更好。
memozied的意思是let后面关联的block只执行一次，然后会缓存改变量，提高执行效率，有需要时才会加载，相较于before执行速度会更快。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let(:github) { 'ucooling.github.io' }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>before</li>
</ul>


<p>let和before(:each)的区别，let不会自动初始化变量，而before(:each)会自动初始化变量，如果我期中有些测试用例不需要初始化这些变量，建议使用let，这样会节省一些时间和资源。before(:all)同样</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Thing
</span><span class='line'>  def tests
</span><span class='line'>      @tests ||= []
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>describe Thing do
</span><span class='line'>  before(:each) do
</span><span class='line'>      @thing = Thing.new
</span><span class='line'>  end
</span><span class='line'>  describe "initialized in before(:each)" do
</span><span class='line'>      it "has 0 tests" do
</span><span class='line'>          @thing.should have(0).tests
</span><span class='line'>      end
</span><span class='line'>      it "can get accept new tests" do
</span><span class='line'>          @thing.tests &lt;&lt; Object.new
</span><span class='line'>      end
</span><span class='line'>      it "does not share state across examples" do
</span><span class='line'>          @thing.should have(0).tests
</span><span class='line'>      end
</span><span class='line'>      it "does not have 1 count" do
</span><span class='line'>          @thing.shou*ld_not have(1).tests
</span><span class='line'>      end
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>expect</li>
</ul>


<p>expect用来改变一个值或者抛出一个异常。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>expect { 
</span><span class='line'>BlogPost.create :title =&gt; “Hello” 
</span><span class='line'>}.to change {BlogPost.count}.by(1) </span></code></pre></td></tr></table></div></figure>


<p>希望在expect块里做完之后，BlogPost.count的值要改为1</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/06/rspec-ru-men/">Rspec 入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-06T21:49:27+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:49 pm</span></time>
        
           | <a href="/blog/2015/04/06/rspec-ru-men/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/06/rspec-ru-men/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Rspec介绍</h2>

<p>Rspec工具是一个Ruby软件包，可以用它构建有关您的软件规范，该规范实际上是一个描述系统行为的测试</p>

<h2>关于TDD</h2>

<p>很多人对于写测试的第一印象可能是：</p>

<ul>
<li>写测试很无聊</li>
<li>写测试很浪费时间</li>
<li>测试很难写</li>
<li>测试对于开发的帮助不大</li>
</ul>


<p>但是我现在想说，其实一开始接触写测试的时候我也同样觉得这种方式很浪费时间，而且有的测试确实很难写，增加了学习的成本，且收效甚微，但是当我慢慢在工作中发现他的好处的时候，我的这种想法慢慢的发生了改变，写测试其实是有很多的好处的</p>

<ul>
<li>开发之前写测试可以保证你的代码的正确性，保证你做的事情是正确的。</li>
<li>当之后再对代码进行重构或者添加新的功能的时候，测试可以保证你新加的代码不会影响以前的功能</li>
<li>可以采用TDD的开发方式，在写测试的过程中可以提前对你的代码进行设计，在以后测试可以当成你代码的文档，不用再去写一些注释或者其他的一些文档。</li>
</ul>


<p>而且现在很多公司的开发也开始越来越重视测试，足以说明测试的重要性，也是作为一个码农必须去学习和研究的知识。</p>

<h2>Rspec安装</h2>

<p>在Gemfile配置文件中，按照下面的代码进行配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group :development, :test do
</span><span class='line'>  gem 'rspec'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>执行一下命令来安装gem包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<h2>测试的目录结构</h2>

<p>通过执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rspec --init</span></code></pre></td></tr></table></div></figure>


<p>它将会生成spec路径和spec_helper.rb文件，下图中的spec下的其他路劲均为手动添加。</p>

<ul>
<li>目录结构</li>
</ul>


<p><img src="/images/spec_1.png" alt="spec目录结构" /></p>

<ul>
<li>spec_helper.rb</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RSpec.configure do |config|
</span><span class='line'>  config.expect_with :rspec do |expectations|
</span><span class='line'>    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
</span><span class='line'>  end
</span><span class='line'>  config.mock_with :rspec do |mocks|
</span><span class='line'>    mocks.verify_partial_doubles = true
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<h2>开始写测试</h2>

<p>还是在spec目录下，你可以只是简单地定义一个XX.rb的测试文件，如果项目比较大，你也可以用目录的结构进行组织。</p>

<ul>
<li>测试的简单结构如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'spec_helper'
</span><span class='line'>
</span><span class='line'>before do
</span><span class='line'>  ......
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>after do
</span><span class='line'>  ......
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>describe XXX do
</span><span class='line'>  it XXX do
</span><span class='line'>      ......
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<blockquote><p>下一节我会开始介绍如何编写自己的测试。</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/02/ruby-aws-sqs/">Ruby-aws-sqs(send_message)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-02T21:11:27+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>9:11 pm</span></time>
        
           | <a href="/blog/2015/04/02/ruby-aws-sqs/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/04/02/ruby-aws-sqs/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>如何在Ruby中使用AWS的SQS</h2>

<blockquote><p>SQS(Simple Queue Service)是一个伸缩且可靠的消息传递框架，可以使用SQS简单地创建、存储和获取信息，可以使用它构建基于AWS的应用程序。使用SQS是构建松耦合的Web应用程序的好方法，只需要根据使用量付费，整个队列框架在Amazon数据中心的安全环境中运行。</p></blockquote>

<h2>SQS提供以下的特性：</h2>

<ul>
<li><p>可靠性
SQS能够跨多个数据中心冗余地存储消息，保证他们随时可用。</p></li>
<li><p>简单性
访问和使用SQS的编程模型非常的简单，而且可以可以通过多种编程语言使用SQS。</p></li>
<li><p>安全性
SQS提供很高的安全水平，只允许授权的用户消费消息。</p></li>
<li><p>可伸缩性
可以使用SQS创建基于队列的应用程序，这些程序可以读写数量不限的消息。</p></li>
<li><p>低成本
SQS以非常低廉的费率满足您的消息传递需求。</p></li>
</ul>


<h2>设计考虑因素</h2>

<ul>
<li>SQS不保证队列中消息的次序</li>
<li>SQS不保证删除队列中的消息</li>
<li>SQS不保证在查询是返回队列中的所有消息</li>
</ul>


<h2>用Ruby使用SQS的简单Demo</h2>

<ul>
<li>设置环境变量(sqs_config.rb)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'aws-sdk'
</span><span class='line'>
</span><span class='line'>module Sqs
</span><span class='line'>  include App::Config
</span><span class='line'>  credential = Aws::Credentials.new(config.sqs_access_key, config.sqs_secret_access_key)
</span><span class='line'>  Aws.config.update({
</span><span class='line'>                     credentials: credential,
</span><span class='line'>                     region: config.sqs_region })
</span><span class='line'>  
</span><span class='line'>  SQS = Aws::SQS::Client.new
</span><span class='line'>  def send_message(msg)
</span><span class='line'>    SQS.send_message(queue_url: config.sqs_endpoint, message_body: msg)
</span><span class='line'>  end
</span><span class='line'>end </span></code></pre></td></tr></table></div></figure>


<ul>
<li>将环境变量提取出来，单独设置</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module App
</span><span class='line'>   module Config
</span><span class='line'>    def sqs_access_key
</span><span class='line'>      'xxxxx'
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    def sqs_secret_access_key
</span><span class='line'>      'xxxxx'
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    def sqs_region
</span><span class='line'>      'xxxxxxxx'
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    def sqs_endpoint
</span><span class='line'>      'https://sqs.xxxxxxxxx.amazonaws.com/xxxxxxxx/contacts-info'
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>`</p>

<ul>
<li>发送消息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include 'sqs_config'
</span><span class='line'> send_message(msg)</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<p> <a href="http://blog.csdn.net/menxu_work/article/details/38296043">AWS Ruby Demo</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/31/ren-shi-node-%5B%3F%5D/">认识Node(一)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-31T17:46:32+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:46 pm</span></time>
        
           | <a href="/blog/2015/03/31/ren-shi-node-%5B%3F%5D/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/03/31/ren-shi-node-%5B%3F%5D/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>为啥学习Node</h2>

<blockquote></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/30/soapjian-jie/">SOAP Jian Jie</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-30T00:00:00+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="/blog/2015/03/30/soapjian-jie/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/03/30/soapjian-jie/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>SOAP简介</h1>

<blockquote><p>SOAP是基于XML的简单协议，可使应用程序在HTTP之上进行信息交换。
对于应用程序开发来说，不同程序之间通过英特网通信非常重要。
目前使用比较多得还有RPC（Remote Procedure Call Protocol），它也是一种远程过程调用协议，它是通过网络从远程计算机程序上请求服务，但是这种方式存在很多的安全问题以及兼容性问题，防火墙和代理服务器通常会阻止此类流量。
SOAP提供了一种标准的方法，使得运行在不同操作系统并使用不同技术的应用程序之间可以相互交通信。</p></blockquote>

<h1>为什么需要SOAP</h1>

<blockquote><p>随着计算机技术的不断发展，现在企业面临的环境越来越复杂，其信息系统大多数为平台、多系统的复杂系统，这就要求今天的企业解决方案具有广泛的兼容能力，可以支持不同的系统平台、数据格式和多种连接方式，要求在Internet环境下，实现系统的松散耦合和跨平台，而且要求提供对Web应用程序的可靠访问。
随着异种计算环境的不断增加，各种系统间的互操作性就愈显得必要，要求系统能够无缝地进行通信和共享数据，从而在 Internet 环境下，消除巨大的信息孤岛，实现信息共享、进行数据交换，达到信息的一致性。Web services 希望实现不同的系统之间能够用"软件-软件对话"的方式相互调用，打破了软件应用、网站和各种设备之间的格格不入的状态，实现"基于WEB无缝集成"的目标。</p></blockquote>

<h1>SOAP语法</h1>

<blockquote><p>一条soap消息其实就是一个普通的xml，但是对于这个XML又有一些条件必须包含以下的元素：</p></blockquote>

<h2>必须有 Envelope元素， 该元素可把XML文件标识为一条soap消息。</h2>

<ul>
<li>它的值始终应当是<a href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a></li>
</ul>


<p><code>&lt;?xml version="1.0"?&gt;
&lt;soap:Envelope
xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;
  ...
  Message information goes here
  ...
&lt;/soap:Envelope&gt;</code></p>

<blockquote><p>soap消息必须拥有命名空间<code>http://www.w3.org/2001/12/soap-envelope</code>相关联的一个Envelope元素，如果使用了不同的命名空间，应用程序就会发生错误，并抛弃此消息。</p></blockquote>

<h2>可选的 Header元素， 用来定义包含的头部信息。</h2>

<blockquote><p>该元素包含SOAP消息的应用程序专用消息（比如认证、支付等），如果Header元素被定义，那么它必须是Envelope元素的第一个子元素。</p></blockquote>

<p><code>&lt;soap:Header&gt;
&lt;m:Trans
xmlns:m="http://www.w3school.com.cn/transaction/"
soap:mustUnderstand="1"&gt;234&lt;/m:Trans&gt;
&lt;/soap:Header&gt;</code></p>

<blockquote><p>SOAP在默认的命名空间中定义了三个属性，这三个属性分别是：actor、mustUnderstand以及encodingStyle。这些被定义在SOAP头部的属性可定义容器如何对SOAP消息进行处理。</p></blockquote>

<h3>actor</h3>

<blockquote><p>通过沿着消息路径经过不同的端点，SOAP 消息可从某个发送者传播到某个接收者。并非 SOAP 消息的所有部分均打算传送到 SOAP 消息的最终端点，不过，另一个方面，也许打算传送给消息路径上的一个或多个端点。</p></blockquote>

<p><code>&lt;soap:Header&gt;
&lt;m:Trans
xmlns:m="http://www.w3school.com.cn/transaction/"
soap:actor="http://www.w3school.com.cn/appml/"&gt;
234
&lt;/m:Trans&gt;
&lt;/soap:Header&gt;</code></p>

<h3>mustUnderstand</h3>

<blockquote><p>SOAP 的 mustUnderstand 属性可用于标识标题项对于要对其进行处理的接收者来说是强制的还是可选的。
假如您向 Header 元素的某个子元素添加了 &ldquo;mustUnderstand="1"，则它可指示处理此头部的接收者必须认可此元素。假如此接收者无法认可此元素，则在处理此头部时必须失效。</p></blockquote>

<p><code>soap:mustUnderstand="0|1"</code></p>

<p><code>&lt;soap:Header&gt;
&lt;m:Trans
xmlns:m="http://www.w3school.com.cn/transaction/"
soap:mustUnderstand="1"&gt;
234
&lt;/m:Trans&gt;
&lt;/soap:Header&gt;</code></p>

<h3>encodingStyle</h3>

<blockquote><p>SOAP 的 encodingStyle 属性用于定义在文档中使用的数据类型。此属性可出现在任何元素中，并会被应用到元素的内容及元素的所有子元素上。SOAP 消息没有默认的编码方式</p></blockquote>

<p><code>soap:encodingStyle="URI"</code></p>

<h2>必选的 Body元素，包含所有的调用和响应信息。</h2>

<p>`&lt;?xml version=&ldquo;1.0&rdquo;?>
&lt;soap:Envelope
xmlns:soap=&ldquo;<a href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a>&rdquo;
soap:encodingStyle=&ldquo;<a href="http://www.w3.org/2001/12/soap-encoding">http://www.w3.org/2001/12/soap-encoding</a>&rdquo;></p>

<p>&lt;soap:Body>
   &lt;m:GetPrice xmlns:m=&ldquo;<a href="http://www.w3school.com.cn/prices">http://www.w3school.com.cn/prices</a>&rdquo;>
      &lt;m:Item>Apples&lt;/m:Item>
   &lt;/m:GetPrice>
&lt;/soap:Body></p>

<p>&lt;/soap:Envelope>`</p>

<blockquote><p>上边的例子是请求苹果的价格，对于上边的m:GetPrice和Item元素师应用程序的专用元素，他们并不是SOAP标准的一部分。
而对应的Soap响应应该类似于这样：</p></blockquote>

<p><code>&lt;?xml version="1.0"?&gt;
&lt;soap:Envelope
xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;
&lt;soap:Body&gt;
   &lt;m:GetPriceResponse xmlns:m="http://www.w3school.com.cn/prices"&gt;
      &lt;m:Price&gt;1.90&lt;/m:Price&gt;
   &lt;/m:GetPriceResponse&gt;
&lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;</code></p>

<h2>可选的 Fault元素， 提供有关在处理此消息所发生的错误信息,它必须定义在Body中。</h2>

<blockquote><p>在SOAP中Fault只能出现一次，SOAP拥有下列的子元素：</p></blockquote>

<ul>
<li>faultcode 供识别故障的代码</li>
<li>faultstring 可供人阅读的有关故障的说明</li>
<li>faultactor 有关是谁引发故障的信息</li>
<li>detail 存留涉及</li>
</ul>


<h2>SOAP HTTP Binding</h2>

<blockquote><p>SOAP 方法指的是遵守 SOAP 编码规则的 HTTP 请求/响应。
HTTP + XML = SOAP
SOAP 请求可能是 HTTP POST 或 HTTP GET 请求。
HTTP POST 请求规定至少两个 HTTP 头：Content-Type 和 Content-Length</p></blockquote>

<p><code>POST /item HTTP/1.1
Content-Type: application/soap+xml; charset=utf-8</code></p>

<p><code>POST /item HTTP/1.1
Content-Type: application/soap+xml; charset=utf-8
Content-Length: 250</code></p>

<h4>参考文档</h4>

<p><a href="http://blog.csdn.net/N199109/article/details/23463225">SOAP接口相关知识介绍</a></p>

<p><a href="http://download.csdn.net/detail/oponent1/4819108">SOAP接口中文版</a></p>

<p><a href="http://andot.iteye.com/blog/662787">SOAP和Web service哪些事</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/29/markdown-sync/">Markdown Sync</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-29T23:56:46+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:56 pm</span></time>
        
           | <a href="/blog/2015/03/29/markdown-sync/#disqus_thread"
             data-disqus-identifier="http://ucooling.github.io/blog/2015/03/29/markdown-sync/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<blockquote><p>Markdown是一种轻量的标记语言，它的优势是使用方便，而且学习的成本非常低，常用的标签就10种左右，语法非常简单，一旦熟悉这种Mackdown的语法，会有一种一劳永逸的赶脚。</p></blockquote>

<h2>对Markdown的简单认识</h2>

<blockquote><p>刚才提到，Makdown是一种用来写作的轻量级【标记语言】，它使用简单地语法代替排版，不像我们平常使用的Word等文字处理的软件，需要做大量的排版工作，他让我们在写文章是可以专注于内容，甚至对插图，使用键盘都可以搞定，现在支持Markdown编辑的网站很多，例如像<a href="http://jianshu.io">简书</a>等。</p></blockquote>

<h2>使用Markdown的优点</h2>

<ul>
<li>专注于内容，不用太关注格式。</li>
<li>可以轻松的导出HTML、PDF、或者本身的.md文件。</li>
<li>可读性好，直观。适合几乎所有人得写作语言。</li>
</ul>


<h2>Markdown语法的规则</h2>

<h4>简记表</h4>

<p>  <img src="http://www.onethink.cn/Uploads/Editor/2013-12-13/52aaabb4e7486.png" alt="速记表" /></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    
  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/09/simple-asset-helper-function-for-cdn/">Simple Asset Helper Function for CDN</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/03/elk-log-analysis/">轻量 高效 日志分析架构ELK(elasticsearh+logstash+Kibana)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/17/pact/">Pact 测试</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/09/new-relic-in-ruby-application/">New Relic in Ruby Application</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/08/use-elasticsearch-to-rails/">Use Elasticsearch to Rails</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Malrin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ucooling';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
